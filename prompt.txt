We are building a secure, distributed, and end-to-end encrypted online voting system for a demo using Node.js, PostgreSQL, Redis, Docker Swarm, and RSA-based cryptography.

üí° Project Goals:
Allow users to register and log in via email and password.

Email-based OTP is used to verify identities (no SMS).

Authenticated users can view and vote in elections.

All vote data is end-to-end encrypted and digitally signed with RSA.

Elections and results are protected by JWT-based access control.

The backend is deployed via Docker Swarm.

No frontend code changes required beyond routing; frontend connects via /api/...

üß± Architecture Overview:
Backend: Node.js + Express

DB: PostgreSQL (via Sequelize ORM)

Cache/OTP store: Redis

Security stack:

JWT auth

RSA keypair (via Docker secrets) for E2EE and signing

Signature middleware verifies integrity of submitted votes

Docker Swarm Deployment: Backend, Redis, and Postgres deployed as services with secrets mounted

üß† Distributed Systems Features Required:
Implement a lightweight consensus protocol (Raft-like or basic Paxos) to agree on vote recording between nodes

Include leader election logic (via Redis, gossip, or Swarm service priorities)

Ensure time synchronization across nodes (even if mocked or simulated)

Implement a mutex/lock (e.g., Redis-based or internal) to prevent race conditions during concurrent vote recording

Abstract this logic into a utility or middleware layer to wrap castVote safely

**Testing Guidance for Distributed System:**
- You do NOT need Insomnia, Postman, curl, or any external tool to test the distributed system.
- You can use inline test hooks, dummy endpoints, console logs, or simple scripts for validation.
- The distributed part can be developed and tested independently of backend validation/eligibility fixes.
- Clock/time synchronization must be implemented as part of the distributed system to ensure correct election timing and result visibility.

‚úÖ Already Scaffolded:
Route structure: auth.js, elections.js, vote.js

Controllers stubbed with named exports

Middleware scaffolded: jwtAuth.js, otpLimiter.js, sigVerifier.js

Utility modules: rsa.js, signer.js, otp.js, db.js

Models:

User: email, passwordHash

Election: title, startTime, endTime, isResultsVisible

Vote: candidate, encryptedPayload, signature; with correct relations

Docker Swarm config in swarm-stack.yml

.env uses paths like /run/secrets/rsa_private

üöÄ Your Tasks:
Implement controller logic in authController.js, electionController.js, voteController.js

Complete DB model associations and Redis connection logic

Add OTP send/verify in otp.js, using Redis and mock email sender

Add distributed system logic (leader election, consensus protocol, mutex)

Prevent double voting and data conflicts across nodes

Lock voting using Redis locks or Swarm API if needed

Add console logging at key steps (auth, DB writes, consensus steps, locks)

Write inline test hooks or dummy endpoints that test:

Full user login + OTP

Election creation

Secure vote casting

Signature rejection

Lock failure or retry

Leader failover (mocked)

Database is not yet set up

Guide us through:

Sequelize sync() or migration setup

Redis and Postgres connection via Swarm

Persistent volumes (optional)

üåç Frontend Integration:
All routes are behind /api

CORS is enabled for all origins

Frontend only needs to update the base URL to /api

Rules:
Keep each utility/controller/middleware modular

Do not change Dockerfiles or Swarm YAML

Use console logs for tracing, not production-grade logging

Only inline test logic (no Jest, etc.)

# User Flow and Requirements (Updated)

- User can sign up or log in; user info is stored in PostgreSQL.
- After signup/login, user receives an OTP via email (should use SendGrid, not Twilio/SMS).
- OTP must be entered to complete login or sensitive actions (signup, password change). OTP resend allowed after 60s, max 3 per hour.
- After login, user sees a list of elections they are eligible to vote in (eligibility is set by election creator via allowed domains or email list).
- User can view and vote in eligible elections; presented with candidates.
- After voting, user is redirected to results page, where they can see results for elections they have voted in (live/completed), but only after voting in that election.
- User can change their password, which also requires OTP verification.
- Anyone can create an election, providing all required details, including at least 2 candidates, allowed domains/emails, and time constraints (10 min‚Äì7 days, down to the minute), a title, a description, each candidates' information (name and description).
- Election creator's email is visible on the election card for transparency, but votes are anonymous.
- Election creator can choose whether the election results can be viewed while it is live or only when it is completed
- Election creator cannot delete elections and is always eligible to vote in their own election (cannot remove themselves from eligibility).
- Users can search elections/results.
- Users only see elections they are eligible for (by domain or email) and have been set as visible by the creator before completion.
- after an election ends, any eligible viewer can see the elections.
- The creator of an election is automatically added to the eligibility list and cannot remove themselves.
- All routes are protected as appropriate (JWT, OTP, etc.).