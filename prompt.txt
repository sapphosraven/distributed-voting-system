We are building a secure, distributed, and end-to-end encrypted online voting system for a demo using Node.js, PostgreSQL, Redis, Docker Swarm, and RSA-based cryptography.

üí° Project Goals:
Allow users to register and log in via email and password.

Email-based OTP is used to verify identities (no SMS).

Authenticated users can view and vote in elections.

All vote data is end-to-end encrypted and digitally signed with RSA.

Elections and results are protected by JWT-based access control.

The backend is deployed via Docker Swarm.

No frontend code changes required beyond routing; frontend connects via /api/...

üß± Architecture Overview:
Backend: Node.js + Express

DB: PostgreSQL (via Sequelize ORM)

Cache/OTP store: Redis

Security stack:

JWT auth

RSA keypair (via Docker secrets) for E2EE and signing

Signature middleware verifies integrity of submitted votes

Docker Swarm Deployment: Backend, Redis, and Postgres deployed as services with secrets mounted

üß† Distributed Systems Features Required:
Implement a lightweight consensus protocol (Raft-like or basic Paxos) to agree on vote recording between nodes

Include leader election logic (via Redis, gossip, or Swarm service priorities)

Ensure time synchronization across nodes (even if mocked or simulated)

Implement a mutex/lock (e.g., Redis-based or internal) to prevent race conditions during concurrent vote recording

Abstract this logic into a utility or middleware layer to wrap castVote safely

‚úÖ Already Scaffolded:
Route structure: auth.js, elections.js, vote.js

Controllers stubbed with named exports

Middleware scaffolded: jwtAuth.js, otpLimiter.js, sigVerifier.js

Utility modules: rsa.js, signer.js, otp.js, db.js

Models:

User: email, passwordHash

Election: title, startTime, endTime, isResultsVisible

Vote: candidate, encryptedPayload, signature; with correct relations

Docker Swarm config in swarm-stack.yml

.env uses paths like /run/secrets/rsa_private

üöÄ Your Tasks:
Implement controller logic in authController.js, electionController.js, voteController.js

Complete DB model associations and Redis connection logic

Add OTP send/verify in otp.js, using Redis and mock email sender

Add distributed system logic (leader election, consensus protocol, mutex)

Prevent double voting and data conflicts across nodes

Lock voting using Redis locks or Swarm API if needed

Add console logging at key steps (auth, DB writes, consensus steps, locks)

Write inline test hooks or dummy endpoints that test:

Full user login + OTP

Election creation

Secure vote casting

Signature rejection

Lock failure or retry

Leader failover (mocked)

Database is not yet set up

Guide us through:

Sequelize sync() or migration setup

Redis and Postgres connection via Swarm

Persistent volumes (optional)

üåç Frontend Integration:
All routes are behind /api

CORS is enabled for all origins

Frontend only needs to update the base URL to /api

Rules:
Keep each utility/controller/middleware modular

Do not change Dockerfiles or Swarm YAML

Use console logs for tracing, not production-grade logging

Only inline test logic (no Jest, etc.)