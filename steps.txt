# Step-by-Step Guide to Complete the Secure Distributed Voting System Demo

1. Database Schema & Sequelize Setup
   - Define User, Election, and Vote models with correct fields and associations.
   - User hasMany Vote, Election hasMany Vote, Vote belongsTo User and Election.
   - Remove any redundant model definitions from route files.

2. Sequelize Sync (Dev Mode)
   - In db.js, ensure sequelize.sync({ alter: true }) is called on boot.
   - On backend start, Sequelize will create tables if they don’t exist.

3. Docker Swarm: Service Connectivity
   - Use service names (postgres, redis) in backend configs for hostnames.
   - Ensure .env or config files use these hostnames.

4. Running the Database
   - Start Docker Swarm stack: docker stack deploy -c swarm-stack.yaml voting
   - If needed, connect to the Postgres container and create the DB manually.

5. Redis Connection
   - Use host 'redis' and port 6379 in Redis client config.
   - Test connection on backend boot with console logs.

6. Implementation Checklist
   - Implement controller logic in authController.js, electionController.js, voteController.js.
   - Complete OTP logic in otp.js using Redis.
   - Apply middleware: jwtAuth.js, otpLimiter.js, sigVerifier.js to correct routes.
   - Add console logging at function entry, key variable values, decision points, and errors.
   - Add simple inline test/debug functions in each controller to exercise:
     - Auth flow (register → login → OTP)
     - Election creation and retrieval
     - Vote casting (with encryption + signature)
     - Signature and JWT failure paths

7. Frontend Integration
   - All backend routes are prefixed with /api.
   - CORS is enabled for all origins.
   - Frontend should set base URL to /api.

8. Test the Full Happy Path
   - Register → login → OTP → create election → vote (with encryption/signature) → view results.

9. (Optional) Add Console-Style Debug Tests
   - At the bottom of each controller, add test functions and call them conditionally (e.g., if process.env.DEBUG).

---

Focus on getting the happy path working first. No need for production-grade error handling or test frameworks for this demo.
